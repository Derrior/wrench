Developer DocumentationOther\+: \href{../user/wrench-101.html}{\tt User} -\/ \href{../internal/wrench-101.html}{\tt Internal}

W\+R\+E\+N\+CH 101 is a page and a set of documents that provide detailed information for each W\+R\+E\+N\+CH\textquotesingle{}s \hyperlink{index_overview-users}{classes of users}, and higher-\/level content than the \href{./annotated.html}{\tt A\+PI Reference}. For instructions on how to \hyperlink{install}{install}, run a \hyperlink{getting-started}{first example}, or \hyperlink{getting-started_getting-started-prep}{create a basic W\+R\+E\+N\+C\+H-\/based simulator}, please refer to their respective sections in the documentation.

This {\bfseries Developer 101} guide describes W\+R\+E\+N\+CH\textquotesingle{}s architectural components necessary to build your own W\+MS (Workflow Management Systems). 

\hypertarget{wrench-101_wrench-101-WMS-10000ft}{}\section{10,000-\/ft view of a simulated W\+MS}\label{wrench-101_wrench-101-WMS-10000ft}
A Workflow Management System (W\+MS), i.\+e., the software that makes all decisions and takes all actions for executing a workflow, is implemented in W\+R\+E\+N\+CH as a simulated process. This process has a {\ttfamily main()} function that goes through a simple loop as follows\+:


\begin{DoxyCode}
\textcolor{keywordflow}{while} ( workflow\_execution\_hasnt\_completed\_or\_failed ) \{
  \textcolor{comment}{// interact with services}
  \textcolor{comment}{// wait for an event}
\}
\end{DoxyCode}
\hypertarget{wrench-101_wrench-101-WMS-blueprint}{}\section{Blueprint for a W\+M\+S in W\+R\+E\+N\+CH}\label{wrench-101_wrench-101-WMS-blueprint}
A W\+MS implementation in W\+R\+E\+N\+CH must derive the {\ttfamily \hyperlink{classwrench_1_1_w_m_s}{wrench\+::\+W\+MS}} class, and typically follows the following steps\+:


\begin{DoxyEnumerate}
\item {\bfseries Get references to running services\+:} The {\ttfamily \hyperlink{classwrench_1_1_w_m_s}{wrench\+::\+W\+MS}} base class implements a set of methods named {\ttfamily \hyperlink{classwrench_1_1_w_m_s_a6a2c05d2a60ce335588a25a1b0b7a8e3}{wrench\+::\+W\+M\+S\+::get\+Available\+Compute\+Services()}}, {\ttfamily \hyperlink{classwrench_1_1_w_m_s_aa5a5f673888e1a455ef9fbaff531cb0c}{wrench\+::\+W\+M\+S\+::get\+Available\+Storage\+Services()}}, etc. These methods return sets of services that can be used by the W\+MS to execute its workflow.
\item {\bfseries Acquire information about the services\+:} Some service classes provide methods to get information about the capabilities of the services. For instance, a {\ttfamily \hyperlink{classwrench_1_1_compute_service}{wrench\+::\+Compute\+Service()}} has a {\ttfamily \hyperlink{classwrench_1_1_compute_service_a1b576a22529bd638e6998f0513a44b36}{wrench\+::\+Compute\+Service\+::get\+Num\+Hosts()}} method that makes it possible to find out how many compute hosts the service has access to in total. A {\ttfamily \hyperlink{classwrench_1_1_storage_service}{wrench\+::\+Storage\+Service}} has a {\ttfamily \hyperlink{classwrench_1_1_storage_service_a600a2fc0da8e1c5f1159509f09c2f2f6}{wrench\+::\+Storage\+Service\+::get\+Free\+Space()}} method to find out have many bytes of free space are available to it. Note that these methods actually involve communication with the service, and thus incur (simulated) overhead.
\item {\bfseries Go through a main loop\+:} The heart of the W\+MS\textquotesingle{}s execution consists in going through a loop until the workflow is executed or has failed to execute. This loop consists of two main steps\+:
\begin{DoxyItemize}
\item {\bfseries Interact with services\+:} This is where the W\+MS can cause workflow files to be copied between storage services, and where workflow tasks can be submitted to compute services. See the \href{#wrench-101-WMS-services}{\tt Interacting with services} section below for more details.
\item {\bfseries Wait for an event\+:} This is where the W\+MS is waiting for services to reply with \char`\"{}work done\char`\"{} or \char`\"{}work failed\char`\"{} events. See the \href{#wrench-101-WMS-events}{\tt Workflow execution events} section for more details.
\end{DoxyItemize}
\end{DoxyEnumerate}\hypertarget{wrench-101_wrench-101-WMS-services}{}\section{Interacting with services}\label{wrench-101_wrench-101-WMS-services}
Each service type provides its own A\+PI. For instance, a network proximity service provides methods to query the service\textquotesingle{}s host distance databases. The \href{./annotated.html}{\tt A\+PI Reference} provides all necessary documentation, which also explains which methods are synchronous and which are asynchronous (in which case some \href{#wrench-101-WMS-events}{\tt event} will likely occur in the future). {\itshape However}, the W\+R\+E\+N\+CH developer will find that many methods that one would expect are nowhere to be found. For instance, the compute services do not have methods for compute job submissions!

The rationale for the above is that many methods need to be asynchronous so that the W\+MS can use services concurrently. For instance, a W\+MS could submit a compute job to two distinct compute services asynchronously, and then wait for the service which completes its job first and cancel the job on the other service. Exposing this asynchronicity to the W\+MS would require that the W\+R\+E\+N\+CH developer uses data structures to perform the necessary bookkeeping of ongoing service interactions, and process incoming control messages from the services on the (simulated) network or register many callbacks. Instead, W\+R\+E\+N\+CH provides {\bfseries managers}. One can think of managers are separate threads that handle all asynchronous interactions with services, and which have been implemented for your convenience to make service interactions easy.

For now there are two possible managers\+: a {\bfseries job manager} manager (class {\ttfamily \hyperlink{classwrench_1_1_job_manager}{wrench\+::\+Job\+Manager}}) and a {\bfseries data movement manager} (class {\ttfamily \hyperlink{classwrench_1_1_data_movement_manager}{wrench\+::\+Data\+Movement\+Manager}}). The base {\ttfamily \hyperlink{classwrench_1_1_w_m_s}{wrench\+::\+W\+MS}} class provides two methods for instantiating and starting these managers\+: {\ttfamily \hyperlink{classwrench_1_1_w_m_s_a3f1a1451efda2a41d2d96a41cf229698}{wrench\+::\+W\+M\+S\+::create\+Job\+Manager()}} and {\ttfamily \hyperlink{classwrench_1_1_w_m_s_aaf8902aadfd0542509cd0cae5519bcf3}{wrench\+::\+W\+M\+S\+::create\+Data\+Movement\+Manager()}}. Creating these managers typically is the first thing a W\+MS does. Each manager has its own documented A\+PI, and is discussed further in sections below.\hypertarget{wrench-101_wrench-101-WMS-data}{}\section{Copying workflow data}\label{wrench-101_wrench-101-WMS-data}
The W\+MS may need to explicitly copy files from one storage service to another storage service, e.\+g., to improve data locality when executing workflow tasks. File copies are accomplished through the data movement manager, which provides two methods\+:


\begin{DoxyItemize}
\item {\ttfamily \hyperlink{classwrench_1_1_data_movement_manager_a815bf4ed2a32b39c0e46a6f5a3c10e51}{wrench\+::\+Data\+Movement\+Manager\+::do\+Synchronous\+File\+Copy()}}\+: performs a synchronous file copy (i.\+e., the call will block until the operation completes or fails)
\item {\ttfamily \hyperlink{classwrench_1_1_data_movement_manager_a3ddeb9700a10b5f249b91786e6dddcb0}{wrench\+::\+Data\+Movement\+Manager\+::initiate\+Asynchronous\+File\+Copy()}}\+: performs and asynchronous file copy (i.\+e., the call returns almost immediately, and an \href{#wrench-101-WMS-events}{\tt event} will be generated later on)
\end{DoxyItemize}

Both methods take an optional {\ttfamily \hyperlink{classwrench_1_1_file_registry_service}{wrench\+::\+File\+Registry\+Service}} argument, in which case they will also update this file registry service with a new entry once the file copy has been completed.\hypertarget{wrench-101_wrench-101-WMS-tasks}{}\section{Running workflow tasks}\label{wrench-101_wrench-101-WMS-tasks}
A workflow comprises tasks, and a W\+MS must pack tasks into {\itshape jobs} to execute them. There are two kinds of jobs in W\+R\+E\+N\+CH\+: {\ttfamily \hyperlink{classwrench_1_1_pilot_job}{wrench\+::\+Pilot\+Job}} and {\ttfamily \hyperlink{classwrench_1_1_standard_job}{wrench\+::\+Standard\+Job}}. A pilot job (sometimes called a \char`\"{}placeholder job\char`\"{}) is a concept that is mostly relevant for batch scheduling. In a nutshell, it is a job that allows late binding of tasks to resources. It is submitted to a compute service (provided that service supports pilot jobs), and when a pilot job starts it just looks to the W\+MS like a short-\/lived compute service to which standard jobs can be submitted.

The most common kind of jobs is the standard job. A standard job is a unit of execution by which a W\+MS tells a compute service to do things. More specifically, in its most complete form, a standard job specifies\+:


\begin{DoxyItemize}
\item A vector of {\ttfamily \hyperlink{classwrench_1_1_workflow_task}{wrench\+::\+Workflow\+Task}} to execute;
\item A {\ttfamily std\+::map} of {\ttfamily $<$\hyperlink{classwrench_1_1_workflow_file}{wrench\+::\+Workflow\+File}$\ast$, \hyperlink{classwrench_1_1_storage_service}{wrench\+::\+Storage\+Service} $\ast$$>$} values which specifies from which storage services particular input files should be read and to which storage services output files should be written. (Note that a compute service can be associated to a \char`\"{}by default\char`\"{} storage service upon instantiation);
\item A set of file copy operations to be performed before executing the tasks;
\item A set of file copy operations to be performed after executing the tasks; and
\item A set of file deletion operations to be performed after executing the tasks.
\end{DoxyItemize}

Any of the above can actually be empty, and in the extreme a standard job does nothing.

Standard jobs and pilot jobs are created via the job manager (see multiple versions of the {\ttfamily \hyperlink{classwrench_1_1_job_manager_a7f3873e56c8813c90b66683690d6b328}{wrench\+::\+Job\+Manager\+::create\+Standard\+Job()}} and {\ttfamily \hyperlink{classwrench_1_1_job_manager_a9ef786306730359866e3fd2bd3aadaf7}{wrench\+::\+Job\+Manager\+::create\+Pilot\+Job()}} methods). The job manager thus acts as a job factory, and provides job management methods\+:


\begin{DoxyItemize}
\item {\ttfamily \hyperlink{classwrench_1_1_job_manager_a69de09b0d5ae34cbcf9208be88901728}{wrench\+::\+Job\+Manager\+::submit\+Job()}}\+: used to submit a job to a compute service.
\item {\ttfamily \hyperlink{classwrench_1_1_job_manager_aba90476a89bc0748497879bdf07eea9c}{wrench\+::\+Job\+Manager\+::terminate\+Job()}}\+: used to terminate a previously submitted job.
\item {\ttfamily \hyperlink{classwrench_1_1_job_manager_ab10f770cc7ce3c022f889ad9cc3fcf0b}{wrench\+::\+Job\+Manager\+::forget\+Job()}}\+: used to completely remove all data regarding a completed/failed job.
\item {\ttfamily \hyperlink{classwrench_1_1_job_manager_ad7f55858aa45b87289d5f35c4ccfad56}{wrench\+::\+Job\+Manager\+::get\+Pending\+Pilot\+Jobs()}}\+: used to retrieve a list of previously submitted jobs that have yet to begin executing.
\item {\ttfamily \hyperlink{classwrench_1_1_job_manager_aeb91b23edf40378e49929f47e95f1ea6}{wrench\+::\+Job\+Manager\+::get\+Running\+Pilot\+Jobs()}}\+: used to retrieve a list of currently running jobs.
\end{DoxyItemize}\hypertarget{wrench-101_wrench-101-WMS-events}{}\section{Workflow execution events}\label{wrench-101_wrench-101-WMS-events}
Because the W\+MS, in part via the managers, performs many asynchronous operations, it needs to act as an event handler. This is called by calling the {\ttfamily \hyperlink{classwrench_1_1_w_m_s_a2923b4ec6f7e233693199154d5206d5f}{wrench\+::\+W\+M\+S\+::wait\+For\+And\+Process\+Next\+Event()}} method implemented by the base {\ttfamily \hyperlink{classwrench_1_1_w_m_s}{wrench\+::\+W\+MS}} class. A call to this method blocks until some event occurs. The possible event classes all derive the {\ttfamily \hyperlink{classwrench_1_1_workflow_execution_event}{wrench\+::\+Workflow\+Execution\+Event}} class. A W\+MS can override a method to react to each possible event (the default method does nothing but print some log message). At the time this documentation is being written, these overridable methods are\+:


\begin{DoxyItemize}
\item {\ttfamily \hyperlink{classwrench_1_1_w_m_s_aa00aeb9c502fc794efb4dbe69e800e49}{wrench\+::\+W\+M\+S\+::process\+Event\+Standard\+Job\+Completion()}}\+: react to a standard job completion
\item {\ttfamily \hyperlink{classwrench_1_1_w_m_s_a1e33e5ae8d04d96eb8e03444d78a5c52}{wrench\+::\+W\+M\+S\+::process\+Event\+Standard\+Job\+Failure()}}\+: react to a standard job failure
\item {\ttfamily \hyperlink{classwrench_1_1_w_m_s_a2044fcfb8fdd1908f50303d6faf0a2f0}{wrench\+::\+W\+M\+S\+::process\+Event\+Pilot\+Job\+Start()}}\+: react to a pilot job beginning execution
\item {\ttfamily \hyperlink{classwrench_1_1_w_m_s_ab3b8812e525c47ed3942b8d51b9b31fd}{wrench\+::\+W\+M\+S\+::process\+Event\+Pilot\+Job\+Expiration()}}\+: react to a pilot job expiration
\item {\ttfamily \hyperlink{classwrench_1_1_w_m_s_a61810ee6d81e3eb1d587da28d74bb53e}{wrench\+::\+W\+M\+S\+::process\+Event\+File\+Copy\+Completion()}}\+: react to a file copy completion
\item {\ttfamily \hyperlink{classwrench_1_1_w_m_s_a7aaff45943d82ae56e3d02626cdad6ef}{wrench\+::\+W\+M\+S\+::process\+Event\+File\+Copy\+Failure()}}\+: react to a file copy failure
\end{DoxyItemize}

Each method above takes in an event object as parameter, and each even class offers several methods to inspect the meaning of the event. In the case of failure, the event includes a {\ttfamily \hyperlink{classwrench_1_1_failure_cause}{wrench\+::\+Failure\+Cause}} object, which can be accessed to understand the root cause of the failure.\hypertarget{wrench-101_wrench-101-WMS-exceptions}{}\section{Exceptions}\label{wrench-101_wrench-101-WMS-exceptions}
Most methods in the W\+R\+E\+N\+CH Developer A\+PI throw {\ttfamily \hyperlink{classwrench_1_1_workflow_execution_exception}{wrench\+::\+Workflow\+Execution\+Exception}} instances when exceptions occur. These are exceptions that corresponds to failures during the simulated workflow executions (i.\+e., errors that would occur in a real-\/world execution). Each such exception contains a {\ttfamily \hyperlink{classwrench_1_1_failure_cause}{wrench\+::\+Failure\+Cause}} object, which can be accessed to understand the root cause of the execution failure. Other exceptions (e.\+g., {\ttfamily std\+::invalid\+\_\+arguments}, {\ttfamily std\+::runtime\+\_\+error}) are thrown as well, which are used for detecting mis-\/uses of the W\+R\+E\+N\+CH A\+PI or internal W\+R\+E\+N\+CH errors.\hypertarget{wrench-101_wrench-101-WMS-schedulers}{}\section{Schedulers for decision-\/making}\label{wrench-101_wrench-101-WMS-schedulers}
A large part of what a W\+MS does is make decisions. It is often a good idea for decision-\/making algorithms (often simply called \char`\"{}scheduling algorithms\char`\"{}) to be re-\/usable across multiple W\+MS implementations, or plug-\/and-\/play-\/able for a single W\+MS implementation. For this reason, the {\ttfamily \hyperlink{classwrench_1_1_w_m_s}{wrench\+::\+W\+MS}} constructor takes as parameters two objects (or null pointers if not needed)\+:


\begin{DoxyItemize}
\item {\ttfamily \hyperlink{classwrench_1_1_standard_job_scheduler}{wrench\+::\+Standard\+Job\+Scheduler}}\+: A class that has a {\ttfamily \hyperlink{classwrench_1_1_pilot_job_scheduler_a903c44145dfce2964f90cc856146adbb}{wrench\+::\+Pilot\+Job\+Scheduler\+::schedule\+Pilot\+Jobs()}} method (to be overwritten) that can be invoked at any time by the W\+MS to submit pilot jobs to compute services.
\item {\ttfamily \hyperlink{classwrench_1_1_pilot_job_scheduler}{wrench\+::\+Pilot\+Job\+Scheduler}}\+: A class that has a {\ttfamily \hyperlink{classwrench_1_1_standard_job_scheduler_a1ef07acfece4706f7f172c740a8015c3}{wrench\+::\+Standard\+Job\+Scheduler\+::schedule\+Tasks()}} method (to be overwritten) that can be invoked at any time by the W\+MS to submit tasks (inside standard jobs) to compute services.
\end{DoxyItemize}

Although not required, it is possible to implement most (or even all) decision-\/making in these two methods so at to have a clean separation of concern between the decision-\/making part of the W\+MS and the rest of its functionality. This kind of design is used in the simple example provided in the {\ttfamily examples/simple-\/example} directory.\hypertarget{wrench-101_wrench-101-WMS-logging}{}\section{Logging}\label{wrench-101_wrench-101-WMS-logging}
It is often desirable for the W\+MS to print log output to the terminal. This is easily accomplished using the {\ttfamily wrench\+::\+W\+R\+E\+N\+C\+H\+\_\+\+I\+N\+FO}, {\ttfamily wrench\+::\+W\+R\+E\+N\+C\+H\+\_\+\+D\+E\+B\+UG}, and {\ttfamily wrench\+::\+W\+R\+E\+N\+C\+H\+\_\+\+W\+A\+RN} macros, which are used just like {\ttfamily printf}. Each of these macros corresponds to a different logging level in Sim\+Grid. See the \href{http://simgrid.gforge.inria.fr/simgrid/latest/doc/outcomes_logs.html}{\tt Sim\+Grid logging documentation} for all details.

Furthermore, one can change the color of the log messages with the {\ttfamily \hyperlink{classwrench_1_1_terminal_output_a07c9d9aaefaf7d79fc2cafaa92162813}{wrench\+::\+Terminal\+Output\+::set\+This\+Process\+Logging\+Color()}} method, which takes as parameter a color specification\+:


\begin{DoxyCode}
\hyperlink{classwrench_1_1_terminal_output_a793daa5c24c3613b398f801a75bfa1e0a685e549985c21b52315120ecdbdedbd3}{wrench::TerminalOutput::COLOR\_BLACK}
\hyperlink{classwrench_1_1_terminal_output_a793daa5c24c3613b398f801a75bfa1e0aeaae512b70dc3fd7199ee0610e06b365}{wrench::TerminalOutput::COLOR\_RED}
\hyperlink{classwrench_1_1_terminal_output_a793daa5c24c3613b398f801a75bfa1e0a7fd5b987f631b43b631941d0955a9949}{wrench::TerminalOutput::COLOR\_GREEN}
\hyperlink{classwrench_1_1_terminal_output_a793daa5c24c3613b398f801a75bfa1e0aec7f1f1d23a5f370415d086d38980b43}{wrench::TerminalOutput::COLOR\_YELLOW}
\hyperlink{classwrench_1_1_terminal_output_a793daa5c24c3613b398f801a75bfa1e0a0fede0fa90e0ca54f914b8d897470709}{wrench::TerminalOutput::COLOR\_BLUE}
\hyperlink{classwrench_1_1_terminal_output_a793daa5c24c3613b398f801a75bfa1e0a792bd57a9fd44e1a9754b55c6df686a6}{wrench::TerminalOutput::COLOR\_MAGENTA}
\hyperlink{classwrench_1_1_terminal_output_a793daa5c24c3613b398f801a75bfa1e0aed9315672be90ad25a40e8f39a6313c4}{wrench::TerminalOutput::COLOR\_CYAN}
\hyperlink{classwrench_1_1_terminal_output_a793daa5c24c3613b398f801a75bfa1e0a745c6187163532ca681a89e925dbce69}{wrench::TerminalOutput::COLOR\_WHITE}
\end{DoxyCode}
 