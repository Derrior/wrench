Internal DocumentationOther\+: \href{../user/wrench-101.html}{\tt User} -\/ \href{../developer/wrench-101.html}{\tt Developer}\hypertarget{guide-simplestorage_guide-simplestorage-overview}{}\section{Overview}\label{guide-simplestorage_guide-simplestorage-overview}
A Simple storage service is the simplest possible abstraction for a service that can store and provide workflow files. It has a certain storage capacity, and provides write, read, and delete operations on files. Writes and Reads can be done synchronously or asynchronously. In addition, higher-\/level semantics such as copying a file directly from a storage service to another are provided.\hypertarget{guide-simplestorage_guide-simplestorage-creating}{}\section{Creating a Simple storage service}\label{guide-simplestorage_guide-simplestorage-creating}
In W\+R\+E\+N\+CH, a Simple storage service represents a storage service ({\ttfamily \hyperlink{classwrench_1_1_storage_service}{wrench\+::\+Storage\+Service}}), which is defined by the {\ttfamily wrench\+::\+Simple\+Storage} class. An instantiation of a Simple storage service requires the following parameters\+:


\begin{DoxyItemize}
\item The name of a host on which to start the service (this is the entry point to the service);
\item A capacity in bytes;
\item Maps ({\ttfamily std\+::map}) of configurable properties ({\ttfamily \hyperlink{classwrench_1_1_batch_service_property}{wrench\+::\+Batch\+Service\+Property}}) and configurable message payloads ({\ttfamily \hyperlink{classwrench_1_1_batch_service_message_payload}{wrench\+::\+Batch\+Service\+Message\+Payload}}).
\end{DoxyItemize}

The example below shows how to create an instance of a Simple storage service that runs on host \char`\"{}\+Gateway\char`\"{}, has access to 64\+TiB of storage. Furthermore, the number of maximum concurrent data connections supported by the service is configured to be 8\+:


\begin{DoxyCode}
\textcolor{keyword}{auto} storage\_service = simulation->\hyperlink{classwrench_1_1_simulation_ad1f5c12285ecfaf5a2ce7dab5ec8b4c5}{add}(
          \textcolor{keyword}{new} \hyperlink{classwrench_1_1_simple_storage_service}{wrench::SimpleStorageService}(\textcolor{stringliteral}{"Gateway"}, 
                                  pow(2,46),
                                       \{\{wrench::SimpleStorageProperty::MAX\_NUM\_CONCURRENT\_DATA\_CONNECTIONS
      , \textcolor{stringliteral}{"8"}\}\}
                                      );
\end{DoxyCode}
\hypertarget{guide-simplestorage_guide-simplestorage-using}{}\section{Using a simple storage service}\label{guide-simplestorage_guide-simplestorage-using}
One can interact directly with a simple storage service to check whether the service hosts a particular file or to delete a file\+:


\begin{DoxyCode}
\hyperlink{classwrench_1_1_workflow_file}{wrench::WorkflowFile} *some\_file;

[...]

\textcolor{keywordflow}{if} (storage\_service->lookupFile(some\_file)) \{
  std::cerr << \textcolor{stringliteral}{"File is there! Let's delete it...\(\backslash\)n"};
  storage\_service->deleteFile(some\_file);
\}
\end{DoxyCode}


While there are few other direct interactions are possible (see the documentation of the {\ttfamily \hyperlink{classwrench_1_1_storage_service}{wrench\+::\+Storage\+Service}} and {\ttfamily \hyperlink{classwrench_1_1_simple_storage_service}{wrench\+::\+Simple\+Storage\+Service}} classes), many interactions are via a data movement manager (an instance of the {\ttfamily \hyperlink{classwrench_1_1_data_movement_manager}{wrench\+::\+Data\+Movement\+Manager}} class). This is a helper process that makes it possible interact asynchronously and transparently with storage services. For instance, here is an example of a synchronous file copy\+:


\begin{DoxyCode}
\hyperlink{classwrench_1_1_workflow_file}{wrench::WorkflowFile} *some\_file;
\hyperlink{classwrench_1_1_storage_service}{wrench::StorageService} *src, *dst;

[...]

\textcolor{comment}{// Create a job manager}
\textcolor{keyword}{auto} job\_manager = this->createJobManager();

job\_manager->doSynchronousFileCopy(some\_file, src, dst);
\end{DoxyCode}


The above call blocks until the file copy has completed. An asynchronous file copy would work as follows\+:


\begin{DoxyCode}
\hyperlink{classwrench_1_1_workflow_file}{wrench::WorkflowFile} *some\_file;
\hyperlink{classwrench_1_1_storage_service}{wrench::StorageService} *src, *dst;

[...]

\textcolor{comment}{// Create a job manager}
\textcolor{keyword}{auto} job\_manager = this->createJobManager();

job\_manager->initiateAsynchronousFileCopy(some\_file, src, dst);

[...]

\textcolor{comment}{// Wait for a workflow execution event}
\textcolor{keyword}{auto} \textcolor{keyword}{event} = this->getWorkflow()->waitForNextExecutionEvent();

\textcolor{keywordflow}{if} (event->type == \hyperlink{classwrench_1_1_workflow_execution_event_a5611165191fbc4d121d1b141c748a448a01537cae4bfcc4d44d2746cd9a3f303f}{wrench::WorkflowExecutionEvent::FILE\_COPY\_COMPLETION}
      ) \{
  std::cerr << \textcolor{stringliteral}{"Success!\(\backslash\)n"};
\} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (event->type == \hyperlink{classwrench_1_1_workflow_execution_event_a5611165191fbc4d121d1b141c748a448a01537cae4bfcc4d44d2746cd9a3f303f}{wrench::WorkflowExecutionEvent::FILE\_COPY\_COMPLETION}
      ) \{
  std::cerr << \textcolor{stringliteral}{"Failure!\(\backslash\)n"};
\}
\end{DoxyCode}


See the documentation of the {\ttfamily \hyperlink{classwrench_1_1_data_movement_manager}{wrench\+::\+Data\+Movement\+Manager}} class for all available A\+PI methods. 